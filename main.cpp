#include "stdio.h"
#include "cbor.h"
#include "mbed.h"
#include "mbed_stats.h"
#include "mbed.h"

// uncomment and set up the mbed_memory_status for runtime memory stats
//#include "mbed_memory_status.h"
//#include "mbed_stats.h"


/*
* This file was created to evaluate the performance of the tinycbor repository.
* For activating the run time memory stats used for the evaluation, clone git@github.com:nuket/mbed-memory-status.git and follow the README.
* IMPORTANT: When analyzing stack usage make sure that you do not use printf prior to any output of the stat functions. 
*            printf uses a HUGE amount of stack, much more than theses actual tests. the stats lib outputs the stats with direct calls to mbed-os serial_api.h.
*
* This main contains 5 different tests for evaluating performance. They are run in separate threads to make the memory analysis simpler.
* Note that The code is not portable and builds only for mbed-os.
* These tests are scenarios similar to our CBOR usage in FCC and SDA, and therefore is good reference code on how to use the tinycbor library.
* 
*/


#define CHECK_EXECUTE(cmd) if(cmd != CborNoError) { printf("Fail:%d\n", __LINE__); goto exit; }
#define CHECK_RET(cmd, expected_ret) if(cmd != expected_ret) { printf("Fail:%d\n", __LINE__); goto exit; }
#define CHECK_ZERO_BUF(status, buf) if((buf != NULL && err != CborNoError) || (buf == NULL && err != CborErrorOutOfMemory)) { printf("Fail:%d, %d\n", __LINE__, err); goto exit; }


void encode_test()
{
    /************************************************************************/
    /*                          Encode simple integer 3                     */
    /************************************************************************/
    uint8_t buf[32];
    uint8_t *buf_to_encode = NULL;
    CborError err;
    int int_to_encode = 5;
    size_t len = 0;
    char *warnings = NULL;
    char *errors = NULL;
    CborEncoder encoder, map_encoder;
    cbor_encoder_init(&encoder, buf, sizeof(buf), 0);
    cbor_encode_int(&encoder, int_to_encode);

    // Decode the integer and make sure it equals to int_to_encode
    CborParser parser;
    CborValue value;

    int result;
    if (cbor_parser_init(buf, cbor_encoder_get_buffer_size(&encoder, buf), 0, &parser, &value) != CborNoError)
        goto exit;
    if (!cbor_value_is_integer(&value) ||
        cbor_value_get_int(&value, &result) != CborNoError)
        goto exit;

    /************************************************************************/
    /*                          Encode complicated CBOR                     */
    /************************************************************************/

    // Encode a CBOR similar to our response CBOR in FCC 
    /*
    {
    1 : 7, // Status code
    "warnings" : long warning string of size 200
    "errors" :   long warning string of size 200
    }
    */

    warnings = (char *)malloc(200);
    errors = (char *)malloc(200);

    for (size_t i = 0; i < 199; i++) {
        warnings[i] = 'a';
        errors[i] = 'a';
    }

    warnings[199] = '\0';
    errors[199] = '\0';


    while (true) {
        // Create CBOR map
        cbor_encoder_init(&encoder, buf_to_encode, len, 0);
        err = cbor_encoder_create_map(&encoder, &map_encoder, CborIndefiniteLength); // Use CborIndefiniteLength if map size not known upon creation
        //printf("buf_to_encode = %p, err = %d\n", buf_to_encode, err);
        CHECK_ZERO_BUF(err, buf_to_encode);

        // Create and insert the status
        err = cbor_encode_int(&map_encoder, 1);
        CHECK_ZERO_BUF(err, buf_to_encode);
        err = cbor_encode_int(&map_encoder, 7); // Value
        CHECK_ZERO_BUF(err, buf_to_encode);

        // Create and insert the warnings string
        err = cbor_encode_text_stringz(&map_encoder, "warnings");
        CHECK_ZERO_BUF(err, buf_to_encode);
        err = cbor_encode_text_stringz(&map_encoder, warnings);
        CHECK_ZERO_BUF(err, buf_to_encode);

        // Create and insert the error string
        err = cbor_encode_text_stringz(&map_encoder, "errors");
        CHECK_ZERO_BUF(err, buf_to_encode);
        err = cbor_encode_text_stringz(&map_encoder, errors);
        CHECK_ZERO_BUF(err, buf_to_encode);

        err = cbor_encoder_close_container(&encoder, &map_encoder);
        CHECK_ZERO_BUF(err, buf_to_encode);

        if (buf_to_encode == NULL) {
            len = cbor_encoder_get_extra_bytes_needed(&encoder);
            buf_to_encode = (uint8_t *)malloc(len);
        } else {
            break;
        }
    }

    //print_all_thread_info();
    //print_heap_and_isr_stack_info();

    printf("tinycbor encode flow succeeded!\n");

    return;

exit:
    printf("tinycbor encode flow failed!\n");
}


uint8_t encoded_map[] = { 0xA3, 0x64, 0x6B, 0x65, 0x79, 0x31, 0x01, 0x6E, 0x61, 0x72, 0x72, 0x61, 0x79, 0x5F, 0x69, 0x6E, 0x5F, 0x62, 0x79, 0x74,
0x65, 0x73, 0x52, 0x83, 0x03, 0x6B, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x83, 0x04, 0x05,
0x06, 0x64, 0x6B, 0x65, 0x79, 0x33, 0x74, 0x61, 0x6E, 0x20, 0x69, 0x72, 0x72, 0x65, 0x6C, 0x65, 0x76, 0x61, 0x6E, 0x74,
0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67 };

void decode_test()
{
    /************************************************************************/
    /*                          Encode simple integer 3                     */
    /************************************************************************/
    uint8_t buf[32];
    int int_to_encode = 5;
    CborEncoder encoder;
    cbor_encoder_init(&encoder, buf, sizeof(buf), 0);
    cbor_encode_int(&encoder, int_to_encode);

    // Decode the integer and make sure it equals to int_to_encode
    CborParser parser;
    CborValue value;
    CborValue element;
    size_t len = 0;
    const uint8_t *array_buf;
    const char *received_string;
    size_t i = 0;

    int result = 0;
   

    /*
    printf("cbor value expected: %d, received: %d\n", int_to_encode, result);
    */

    /************************************************************************/
    /*                    Decode the encoded_map                            */
    /************************************************************************/
    CHECK_EXECUTE(cbor_parser_init(encoded_map, sizeof(encoded_map), 0, &parser, &value));

    CHECK_RET(cbor_value_is_map(&value), true);

    //CHECK_EXECUTE(cbor_value_enter_container(&value, &element));

    CHECK_EXECUTE(cbor_value_map_find_value(&value, "array_in_bytes", &element));

    CHECK_RET(cbor_value_is_byte_string(&element), true);

    CHECK_EXECUTE(cbor_value_get_byte_string_chunk(&element, &array_buf, &len, &element));

    /************************************************************************/
    /*                    Decode the encoded_test_array                     */
    /************************************************************************/


    CHECK_EXECUTE(cbor_parser_init(array_buf, len, 0, &parser, &value));

    CHECK_RET(cbor_value_is_array(&value), true);

    // We now iterate over the CBOR array

    // Get first value - the integer 3
    CHECK_EXECUTE(cbor_value_enter_container(&value, &element));

    if (!cbor_value_is_integer(&element) ||
        cbor_value_get_int(&element, &result) != CborNoError)
        goto exit;

    /*
    printf("cbor value expected: %d, received: %d\n", 3, result);
    */

    // Get second value - the string "some string"
    CHECK_EXECUTE(cbor_value_advance(&element));
    if (!cbor_value_is_text_string(&element) ||
        cbor_value_calculate_string_length(&element, &len) != CborNoError)
        goto exit;

    /*
    printf("Received string length: %d\n", (int)len);
    */

    cbor_value_get_text_string_chunk(&element, &received_string, &len, &element);
    /*
    printf("Received string is: %.*s\n", (int)len, received_string);
    */

    // Get third value - the array [4, 5, 6]
    CHECK_EXECUTE(cbor_value_advance(&element));
    if (!cbor_value_is_array(&element)) {
        /*
        printf("Not array, is %d\n", element.type);
        */
        goto exit;
    }

    CHECK_EXECUTE(cbor_value_get_array_length(&element, &len));
    /*
    printf("Inner array length, expected: %d, is: %d\n", 3, len);
    */

    // Loop over values of array
    CHECK_EXECUTE(cbor_value_enter_container(&element, &value));

    for (i = 4; i < len + 4; i++) {
        if (!cbor_value_is_integer(&value) ||
            cbor_value_get_int(&value, &result) != CborNoError)
            goto exit;

        /*
        printf("cbor value expected: %d, received: %d\n", i, result);
        */
        CHECK_EXECUTE(cbor_value_advance(&value));

    }
    //print_all_thread_info();
    //print_heap_and_isr_stack_info();

    printf("tinycbor decode flow succeeded!\n");
    return;

exit:
    printf("tinycbor decode flow failed!\n");
}

/*
[[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[1,[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
,
"hidden string"
]
*/

/*
uint8_t nested_array[] = { 0x82, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82,
0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82,
0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82, 0x01, 0x82,
0x01, 0x80, 0x6D, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67 };
*/
uint8_t nested_array[] = { 0x83, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80, 0x61, 0x78 };

void nested_test()
{

    CborParser parser;
    CborValue value;
    CborValue element;
    size_t len;
    const char *received_string;

    //printf("size of the CBOR: %d\n", sizeof(nested_array));
    CHECK_EXECUTE(cbor_parser_init(nested_array, sizeof(nested_array), 0, &parser, &value));

    CHECK_RET(cbor_value_is_array(&value), true);

    /*CHECK_EXECUTE(cbor_value_get_array_length(&value, &len));
    printf("cbor length expected: %d, received: %d\n", 2, len);*/

    CHECK_EXECUTE(cbor_value_enter_container(&value, &element));
    CHECK_EXECUTE(cbor_value_advance(&element));
    CHECK_EXECUTE(cbor_value_advance(&element));

    if (!cbor_value_is_text_string(&element) ||
        cbor_value_calculate_string_length(&element, &len) != CborNoError)
        goto exit;

    //cbor_value_get_text_string_chunk(&element, &received_string, &len, &element);
    
    //printf("Received string is: %.*s\n", (int)len, received_string);
    

    //print_all_thread_info();
    //print_heap_and_isr_stack_info();

    printf("tinycbor nested array succeeded!\n");
    return;
exit:
    printf("tinycbor nested array flow failed!\n");
}

// cbor_array_of_strings_small:
/* 
[
"str1",
"str2",
"str3"
]
*/
uint8_t cbor_array_of_strings_small[] = { 0x83, 0x64, 0x73, 0x74, 0x72, 0x31, 0x64, 0x73, 0x74, 0x72, 0x32, 0x64, 0x73, 0x74, 0x72, 0x33 };
void array_of_strings_small()
{
    CborParser parser;
    CborValue value;
    CborValue element;

    CHECK_EXECUTE(cbor_parser_init(cbor_array_of_strings_small, sizeof(cbor_array_of_strings_small), 0, &parser, &value));

    CHECK_RET(cbor_value_is_array(&value), true);
    CHECK_EXECUTE(cbor_value_enter_container(&value, &element));
    CHECK_EXECUTE(cbor_value_advance(&element));
    CHECK_EXECUTE(cbor_value_advance(&element));

    //print_all_thread_info();

    printf("tinycbor array_of_strings_small succeeded!\n");
    return;

exit:
    printf("tinycbor array_of_strings_small succeeded!\n");
}

// cbor_array_of_strings_large:
/*
[
"str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1str1",
"str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2str2",
"str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3str3"
]*/
uint8_t cbor_array_of_strings_large[] = { 0x83, 0x78, 0xB4, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73, 0x74, 0x72, 0x31, 0x73,
0x74, 0x72, 0x31, 0x78, 0xB4, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72, 0x32, 0x73, 0x74, 0x72,
0x32, 0x73, 0x74, 0x72, 0x32, 0x78, 0xB4, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33, 0x73,
0x74, 0x72, 0x33, 0x73, 0x74, 0x72, 0x33 };

void array_of_strings_large()
{
    CborParser parser;
    CborValue value;
    CborValue element;

    CHECK_EXECUTE(cbor_parser_init(cbor_array_of_strings_large, sizeof(cbor_array_of_strings_large), 0, &parser, &value));

    CHECK_RET(cbor_value_is_array(&value), true);
    CHECK_EXECUTE(cbor_value_enter_container(&value, &element));
    CHECK_EXECUTE(cbor_value_advance(&element));
    CHECK_EXECUTE(cbor_value_advance(&element));

    //print_all_thread_info();

    printf("tinycbor array_of_strings_large succeeded!\n");
    return;

exit:
    printf("tinycbor array_of_strings_large succeeded!\n");
}

int main(int argc, char * argv[])
{
    
    setvbuf(stdout, (char *)NULL, _IONBF, 0); /* Avoid buffering on test output */

    Thread t_decode(osPriorityNormal, 5 * 1024 /* 8K stack */);
    t_decode.start(&decode_test);
    t_decode.join();

    Thread t_encode(osPriorityNormal, 5 * 1024 /* 8K stack */);
    t_encode.start(&encode_test);
    t_encode.join();

    Thread t_nested_test(osPriorityNormal, 5 * 1024);
    t_nested_test.start(&nested_test);
    t_nested_test.join();

    // Both t_array_of_strings_small and t_array_of_strings_large tasks use 248 stack bytes

    Thread t_array_of_strings_small(osPriorityNormal, 5 * 1024);
    t_array_of_strings_small.start(&array_of_strings_small);
    t_array_of_strings_small.join();

    Thread t_array_of_strings_large(osPriorityNormal, 5 * 1024);
    t_array_of_strings_large.start(&array_of_strings_large);
    t_array_of_strings_large.join();

    printf("tinycbor flow succeeded!\n");

    return 0;
}